;;; swan 
;; exp types
IMAGINARY_i = 7,
IMAGINARY_j = 8,
IMAGINARY_k = 9,

;; order lookup
[EXP_TYPE.IMAGINARY_i] = 15,
[EXP_TYPE.IMAGINARY_j] = 16,
[EXP_TYPE.IMAGINARY_k] = 17,

;; singletons
local imag_i = {}
imag_i.type = EXP_TYPE.IMAGINARY_i
; set metatable imaginary i

local imag_j = {}
imag_j.type = EXP_TYPE.IMAGINARY_j
; set metatable imaginary j

local imag_k = {}
imag_k.type = EXP_TYPE.IMAGINARY_k
; set metatable imaginary k

;; implement
function M.i()
  return imag_i
end

function M.j()
  return imag_j
end

function M.k()
  return imag_k
end

;; variables
local imag_mt = {}

;; copy metamethods
imag_mt.__pow = sym_mt.__pow
imag_mt.__add = sym_mt.__add
imag_mt.__sub = sym_mt.__sub
imag_mt.__mul = sym_mt.__mul
imag_mt.__div = sym_mt.__div

;; set metatable imaginary i
setmetatable(imag_i, imag_mt)

;; set metatable imaginary j
setmetatable(imag_j, imag_mt)

;; set metatable imaginary k
setmetatable(imag_k, imag_mt)

;; implement
function imag_mt:__tostring()
  if self.type == imag_i.type then
    return "i"
  elseif self.type == imag_j.type then
    return "j"
  elseif self.type == imag_k.type then
    return "k"
  end
end

;; variables
local imag_methods = {}

;; copy metamethods
imag_mt.__index = imag_methods

;; implement
function imag_methods:normal_form()
	return self
end

;; lookups
local imag_mul = {}
imag_mul[1] = {}
imag_mul[imag_i] = {}
imag_mul[imag_j] = {}
imag_mul[imag_k] = {}

imag_mul[1][imag_i] = {1, imag_i}
imag_mul[1][imag_j] = {1, imag_j}
imag_mul[1][imag_k] = {1, imag_k}

imag_mul[imag_i][1] = {1, imag_i}
imag_mul[imag_j][1] = {1, imag_j}
imag_mul[imag_k][1] = {1, imag_k}

imag_mul[imag_i][imag_i] = {-1, 1}
imag_mul[imag_j][imag_i] = {-1, imag_k}
imag_mul[imag_k][imag_i] = {1, imag_j}

imag_mul[imag_i][imag_j] = {1, imag_k}
imag_mul[imag_j][imag_j] = {-1, 1}
imag_mul[imag_k][imag_j] = {-1, imag_i}

imag_mul[imag_i][imag_k] = {-1, imag_j}
imag_mul[imag_j][imag_k] = {1, imag_i}
imag_mul[imag_k][imag_k] = {-1, 1}

local is_imag = {}
is_imag[EXP_TYPE.IMAGINARY_i] = true
is_imag[EXP_TYPE.IMAGINARY_j] = true
is_imag[EXP_TYPE.IMAGINARY_k] = true

;; combine imaginary factor mul
local current_imag = 1
local current_imag_sign = 1

new_children_simplified = {}
for i=1,#children_simplified do
  if is_imag[children_simplified[i].type] then
    local sign, res = unpack(imag_mul[current_imag][children_simplified[i]])
    current_imag_sign = current_imag_sign * sign
    current_imag = res
  else
    table.insert(new_children_simplified, children_simplified[i])
  end
end

if current_imag ~= 1 or current_imag_sign ~= 1 then
  if current_imag_sign == -1 then
    table.insert(new_children_simplified, create_constant(-1))
  end
  if current_imag ~= 1 then
    table.insert(new_children_simplified, current_imag)
  end
end

children_simplified = new_children_simplified

;; copy metamethods
imag_methods.simplify = exp_methods.simplify
imag_methods.expand = exp_methods.expand

;; if imaginary return as is
elseif is_imag[self.type] then
    return self

;; if imaginary then clone
if is_imag[self.type] then
    return self
end

;; exp types
FUNCTION = 10,

;; variables
local FUNCTION_TYPE = {
  UNDEFINED = 1,
  ; function types
}

;; variables
local create_fun_exp
local fun_methods = {}
local fun_mt = {}
fun_mt.__index = fun_methods

;; implement
function create_fun_exp(fun_type)
  local exp = {}
  exp.type = EXP_TYPE.FUNCTION
  exp.args = {}
  exp.fun_type = fun_type or FUNCTION_TYPE.UNDEFINED
  setmetatable(exp, fun_mt)
  return exp
end

;; implement
function fun_mt:__tostring()
  local fun_name = "unknown"
  ; args to string
  if self.fun_type == FUNCTION_TYPE.UNDEFINED then
    fun_name = "undefined"
  ; convert function type to function name
  end

  return fun_name .. "(" .. args_str .. ")"
end

;; function types
EXP = 2,

;; convert function type to function name
elseif self.fun_type == FUNCTION_TYPE.EXP then
  fun_name = "exp"

;; args to string
local args_str = {}
for i=1,#self.args do
  table.insert(args_str, tostring(self.args[i]))
end
args_str = table.concat(args_str, ",")

;; implement
function M.exp(x)
  local fn_exp = create_fun_exp()
  fn_exp.fun_type = FUNCTION_TYPE.EXP
  table.insert(fn_exp.args, x)
  return fn_exp
end

;; implement
function exp_methods:as_real_mat()
  ; collect all quaternion terms
  ; create real matrix from collected terms
  return mat
end

;; copy metamethods
imag_methods.as_real_mat = exp_methods.as_real_mat
sym_methods.as_real_mat = exp_methods.as_real_mat

imag_methods.collect_quat = exp_methods.collect_quat
sym_methods.collect_quat = exp_methods.collect_quat

;; implement
function exp_methods:collect_quat()
  local r = self:expand():simplify()

  local quat_coeffs = {}
  local add_exp
  if r.type ~= EXP_TYPE.ADD then
    add_exp = create_add_exp()
    add_exp.children = { r }
  else
    add_exp = r
  end

  for _, term in ipairs(add_exp.children) do
    local mul_term
    if term.type == EXP_TYPE.MUL then
      mul_term = term
    else
      mul_term = create_mul_exp()
      mul_term.children = { term }
    end

    ; split mul term
    ; fill quat coeffs
  end
  ; fill unfilled quaternion terms
  return quat_coeffs
end

;; collect all quaternion terms
local quat_coeffs = self:collect_quat()

;; split mul term
local idx = 1
local rest = {}
for _, coeff in ipairs(mul_term.children) do
  assert(coeff.type ~= EXP_TYPE.ADD and coeff.type ~= EXP_TYPE.MUL)
  if is_imag[coeff.type] then
    assert(idx == 1)
    if coeff.type == EXP_TYPE.IMAGINARY_i then
      idx = 2
    elseif coeff.type == EXP_TYPE.IMAGINARY_j then
      idx = 3
    elseif coeff.type == EXP_TYPE.IMAGINARY_k then
      idx = 4
    end
  else
    table.insert(rest, coeff)
  end
end

;; fill quat coeffs
assert(not quat_coeffs[idx])
if #rest == 0 then
  quat_coeffs[idx] = M.constant(1)
elseif #rest == 1 then
  quat_coeffs[idx] = rest[1]
else
  local mul_exp = create_mul_exp()
  mul_exp.children = rest
  quat_coeffs[idx] = mul_exp
end

;; fill unfilled quaternion terms
for idx=1,4 do
  if not quat_coeffs[idx] then
    quat_coeffs[idx] = M.constant(0)
  end
end

;; create real matrix from collected terms
local a,b,c,d = unpack(quat_coeffs)
-- One of 48 possibilities to represent a quaternion as a 4x4 matrix
-- https://en.wikipedia.org/wiki/Quaternion#Representation_as_real_4_%C3%97_4_matrices
local mat = M.mat {
  { a, -b, -c, -d },
  { b, a, -d, c },
  { c, d, a, -b },
  { d, -c, b, a },
}
