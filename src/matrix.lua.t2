;;; swan
;; implement
function M.mat_sym(name, dims,flags)
	; expand dims
	local exp = {}
	exp.type = EXP_TYPE.MAT
	exp.name = name
	; set matrix types
	exp.m = m
	exp.n = n
	; create matrix elements
	; register matrix metatable
	return exp
end

;; set matrix types
exp.mat_types = {}
if flags then
	if type(flags) ~= "table" then
		flags = { flags }
	end
	for _, flag in ipairs(flags) do
		; set matrix flag
		exp.mat_types[flag] = true
	end
end

;; expand dims
local m,n
if type(dims) == "number" then
	m = dims
	n = dims
elseif #dims == 2 then
	m = dims[1]
	n = dims[2]
elseif #dims == 1 then
	m = dims[1]
	n = dims[1]
else
	assert(false)
end

;; exp types
MAT = 15,

;; variables
local MAT_TYPE = {
	; mat types
}

;; create matrix elements
exp.elems = {}
for i=1,m do
	exp.elems[i] = {}
	for j=1,n do
		; create matrix element
		exp.elems[i][j] = mat_elem
	end
end

;; exp types
MAT_ELEM = 16,

;; create matrix element
local mat_elem = {}
mat_elem.type = EXP_TYPE.MAT_ELEM
mat_elem.i = i
mat_elem.j = j
mat_elem.mat = exp

; register matrix element metamethods

;; variables
local mat_mt = {}
local mat_methods = {}
mat_mt.__index = mat_methods

;; implement
function mat_mt:__tostring()
	local result = ""
	; print utility for matrix sets
	; determine smallest matrix group set
	; print each elements if there are values
	; otherwise just print matrix name
	; format output mat tostring
	return result
end

;; variables
local to_sup

;; implement
function to_sup(s)
	local r = ""
	for i=1,#s do
		r = r .. superscript[s:sub(i,i)]
	end
	return r
end

;; variables
local real_bb = "ℝ"
local latex_symbols = {
	["in"] = "∈"
	; latex symbols
}

;; determine smallest matrix group set
local matrix_set = ""
if vim.tbl_count(self.mat_types) == 0 then
	matrix_set = real_bb .. to_sup(tostring(self.m)) .. to_sup("x") .. to_sup(tostring(self.n))
; display matrix set
end

;; print each elements if there are values
if self.elems[1] and self.elems[1][1] and self.elems[1][1].value then
	; print matrix elems explicit

;; otherwise just print matrix name
else
	result = result .. self.name
end

;; format output mat tostring
result = result .. " " .. latex_symbols["in"] .. " " .. matrix_set

;; register matrix metatable
setmetatable(exp, mat_mt)

;; mat types
INVERTIBLE = 1,
ORTHOGONAL = 2,
SPECIAL_ORTHOGONAL = 3,
SYMMETRIC = 4,
POSITIVE_DEFINITE = 5,
POSITIVE_SEMIDEFINITE = 6,
NEGATIVE_SEMIDEFINITE = 7,
NEGATIVE_DEFINITE = 8,

;; set matrix flag
if flag == MAT_TYPE.ORTHOGONAL or flag == MAT_TYPE.SPECIAL_ORTHOGONAL or flags == MAT_TYPE.POSITIVE_DEFINITE or flags == MAT_TYPE.NEGATIVE_DEFINITE then
	exp.mat_types[MAT_TYPE.INVERTIBLE] = true
end

if flag == MAT_TYPE.SPECIAL_ORTHOGONAL then
	exp.mat_types[MAT_TYPE.ORTHOGONAL] = true
end

;; print utility for matrix sets
local get_dim = function()
	if self.m == self.n then
		return "(" .. tostring(self.m) .. ")"
	else
		return "(" .. tostring(self.m) .. "," .. tostring(self.n) .. ")"
	end
end

;; determine smallest matrix group set
if vim.tbl_count(self.mat_types) == 1 and self.mat_types[MAT_TYPE.INVERTIBLE] then
	matrix_set = "GL" .. get_dim()
end

;; determine smallest matrix group set
if self.mat_types[MAT_TYPE.ORTHOGONAL] then
	if self.mat_types[MAT_TYPE.SPECIAL_ORTHOGONAL] then
		matrix_set = "SO" .. get_dim()
	else
		matrix_set = "O" .. get_dim()
	end
end

;; implement
function M.mat_sym_o(...)
	local args = { ... }
	table.insert(args, MAT_TYPE.ORTHOGONAL)
	return M.mat_sym(unpack(args))
end

function M.mat_sym_so(...)
	local args = { ... }
	table.insert(args, MAT_TYPE.SPECIAL_ORTHOGONAL)
	return M.mat_sym(unpack(args))
end

function M.mat_sym_gl(...)
	local args = { ... }
	table.insert(args, MAT_TYPE.INVERTIBLE)
	return M.mat_sym(unpack(args))
end

;; implement
function M.mat(arr, flags)
	local exp = {}
	exp.type = EXP_TYPE.MAT
	; set matrix types
	local m = #arr
	local n = #arr[1]
	exp.m = m
	exp.n = n
	; create matrix elements from array
	; register matrix metatable
	return exp
end

;; create matrix elements from array
exp.elems = {}
for i=1,m do
	exp.elems[i] = {}
	for j=1,n do
		; create matrix element
		; set mat elem with array
		exp.elems[i][j] = mat_elem
	end
end

;; set mat elem with array
mat_elem.value = arr[i][j]

;; implement
function M.mat_o(...)
	local args = { ... }
	table.insert(args, MAT_TYPE.ORTHOGONAL)
	return M.mat(unpack(args))
end

function M.mat_so(...)
	local args = { ... }
	table.insert(args, MAT_TYPE.SPECIAL_ORTHOGONAL)
	return M.mat(unpack(args))
end

function M.mat_gl(...)
	local args = { ... }
	table.insert(args, MAT_TYPE.INVERTIBLE)
	return M.mat(unpack(args))
end

;; print matrix elems explicit
local rows = {}
for i=1,self.m do
	local row = {}
	for j=1,self.n do
		table.insert(row, tostring(self.elems[i][j].value))
	end
	local border_right, border_left
	; determine border right and left
	table.insert(row, 1, border_left)
	table.insert(row, border_right)
	table.insert(rows, row)
end

; normalize all matrix cells
local matrix_str = ""
; concat all cells

result = result .. matrix_str

;; determine border right and left
if self.m == 1 then
	border_left = "⟮"
	border_right = "⟯"
elseif i == 1 then
	border_left = "⎡"
	border_right = "⎤"
elseif i == self.m then
	border_left = "⎣"
	border_right = "⎦"
else
	border_left = "⎢"
	border_right = "⎥"
end

;; normalize all matrix cells
for j=1,#rows[1] do
	local max_width = 0
	for i=1,#rows do
		local cell_width = vim.api.nvim_strwidth(rows[i][j])
		; add one width if no minus sign
		max_width = math.max(max_width, cell_width)
	end
	for i=1,self.m do
		; prepend space if no minus sign
		while vim.api.nvim_strwidth(rows[i][j]) < max_width do
			rows[i][j] = rows[i][j] .. " "
		end
	end
end

;; concat all cells
local all_rows = {}
for i=1,#rows do
	local row
	row = table.concat(rows[i], " ")
	table.insert(all_rows, row)
end
matrix_str = table.concat(all_rows, "\n")

;; add one width if no minus sign
if #rows[i][j] == 0 or rows[i][j]:sub(1,1) ~= "-" then
	cell_width = cell_width + 1
end
;; prepend space if no minus sign
if #rows[i][j] == 0 or rows[i][j]:sub(1,1) ~= "-" then
	rows[i][j] = " " .. rows[i][j]
end
