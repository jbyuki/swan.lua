;;; swan
;; exp types
ADD_MAT = 17,
MUL_MAT = 18,

;; variables
local create_mat_add
local create_mat_mul
local mat_add_mt = {}
local mat_mul_mt = {}

local mat_add_methods = {}
local mat_mul_methods = {}
mat_add_mt.__index = mat_add_methods
mat_mul_mt.__index = mat_mul_methods

;; implement
function create_mat_add()
  local exp = {}
  exp.type = EXP_TYPE.ADD_MAT
  exp.children = {}
  return setmetatable(exp, mat_add_mt)
end

function create_mat_mul()
  local exp = {}
  exp.type = EXP_TYPE.MUL_MAT
  exp.children = {}
  return setmetatable(exp, mat_mul_mt)
end

;; implement
function mat_mt:__add(other)
  assert(self.m == other.m)
  assert(self.n == other.n)
  local add_children = {}
  for _, elem in ipairs({self, other}) do
    if elem.type == EXP_TYPE.ADD_MAT then
      for _, child in ipairs(elem.children) do
        table.insert(add_children, child)
      end
    else
      table.insert(add_children, elem)
    end
  end

  local exp = create_mat_add()
  exp.children = add_children
  exp.m = self.m
  exp.n = self.n
  return exp
end

;; copy metamethods
mat_add_mt.__add = mat_mt.__add
mat_mul_mt.__add = mat_mt.__add

;; implement
function mat_add_mt:__tostring()
  local tbl = {}
  for i=1,#self.children do
    table.insert(tbl, grid_new(tostring(self.children[i])))
  end
  local result = grid_hori_concat(tbl, grid_new(" + "))
  return tostring(result)
end

;; implement
function mat_mul_mt:__tostring()
  local tbl = {}
  for i=1,#self.children do
    local g = grid_new(tostring(self.children[i]))
    if self.children[i].type == EXP_TYPE.ADD_MAT then
      g:enclose_paren()
    end
    table.insert(tbl, g)
  end
  local result = grid_hori_concat(tbl)
  return tostring(result)
end

;; implement
function mat_mt:__mul(other)
  assert(self.n == other.m)
  local mul_children = {}
  for _, elem in ipairs({self, other}) do
    if elem.type == EXP_TYPE.MUL_MAT then
      for _, child in ipairs(elem.children) do
        table.insert(mul_children, child)
      end
    else
      table.insert(mul_children, elem)
    end
  end

  local exp = create_mat_mul()
  exp.children = mul_children
  exp.m = self.m
  exp.n = other.n
  return exp
end

;; copy metamethods
mat_add_mt.__mul = mat_mt.__mul
mat_mul_mt.__mul = mat_mt.__mul

;; implement
function mat_methods:expand()
  if self.type == EXP_TYPE.ADD_MAT then
    local result = create_mat_add()
    for i=1,#self.children do
      table.insert(result.children, self.children[i]:expand())
    end
    return result
  elseif self.type == EXP_TYPE.MUL_MAT then
    local expanded_children = {}
    for _, child in ipairs(self.children) do
      table.insert(expanded_children, child:expand())
    end
    ; distribute matrices

    local exp
    if #new_children > 1 then
      exp = create_mat_add()
      exp.children = new_children
    else
      exp = new_children[1]
    end
    return exp
  else

    return self
  end
end

;; copy metamethods
mat_add_methods.expand = mat_methods.expand
mat_mul_methods.expand = mat_methods.expand

;; distribute matrices
local new_children = {}

local idx = {}
for i=1,#expanded_children do
	idx[i] = 1
end

while true do
	; create mul expression from idx matrix
	; increment idx matrix
end

;; create mul expression from idx matrix
local exp = create_mat_mul()

for i=1,#expanded_children do
	local child = nil
	if expanded_children[i].type == EXP_TYPE.ADD_MAT then
		child = expanded_children[i].children[idx[i]]
	else
		child = expanded_children[i]
	end

	; if child is multiplication flatten structure matrix
	; otherwise just add child
end

table.insert(new_children, exp)

;; if child is multiplication flatten structure matrix
if child.type == EXP_TYPE.MUL_MAT then
	for _,grandchild in ipairs(child.children) do
		table.insert(exp.children, grandchild)
	end

;; increment idx matrix
local good = false
for i=1,#idx do
	if expanded_children[i].type == EXP_TYPE.ADD_MAT then
		if idx[i] + 1 <= #expanded_children[i].children then
			idx[i] = idx[i] + 1
			good = true
			break
		else
			idx[i] = 1
		end
	end
end

if not good then
	break
end
