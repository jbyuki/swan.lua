;;; swan
;; exp types
RATIONAL = 6,

;; order lookup
[EXP_TYPE.RATIONAL] = 10,

;; variables
local create_rational
local rational_mt = {}
local rational_methods = {}

;; copy metamethods
rational_mt.__index = rational_methods

;; implement
function create_rational(num, den)
  assert(den ~= 0)

	local rational = {}
	rational.type = EXP_TYPE.RATIONAL
	rational.num = num
	rational.den = den
  rational = setmetatable(rational, rational_mt)
  return rational
end

;; variables
local isint

;; implement
function isint(n)
  return math.floor(n) == n
end

;; implement
function rational_methods:gcd()
  assert(isint(self.num))
  assert(isint(self.den))

  local a = self.num
  local b = self.den
  local t
  while b ~= 0 do
    t = b
    b = math.fmod(a,b)
    a = t
  end

  local num = self.num / a
  local den = self.den / a

  if den == 1 then
    return create_constant(num)
  else
    return create_rational(num, den)
  end
end

;; implement
function rational_methods:normal_form()
  return self:gcd()
end

;; implement
function constant_mt:__div(other)
	if other.type == EXP_TYPE.CONSTANT then
		return create_rational(self.value, other.value):gcd()
	elseif other.type == EXP_TYPE.RATIONAL then
		return create_rational(self.value * self.den, other.num):gcd()
	else
		assert(false)
	end
end

;; implement
function rational_mt:__div(other)
	if other.type == EXP_TYPE.CONSTANT then
		return create_rational(self.num, self.den * other.value):gcd()
	elseif other.type == EXP_TYPE.RATIONAL then
		return create_rational(self.num * self.den, self.den * other.num):gcd()
	else
		assert(false)
	end
end

;; implement
function rational_mt:__tostring()
  return "(" .. tostring(self.num) .. "/" .. tostring(self.den) .. ")"
end
